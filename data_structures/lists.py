print("Data structures are containers of data that organize and group different kinds of data types together in different ways")
print("All data structures are data types- Because data types are just a way to classify data- and data structures do that")
print("These containers give Python much more power to develop complex programs. The data structures in Python are: \n\t{}, \n\t{}, \n\t{}, \n\t{}".format("lists", "tuples", "sets", "dictionaries" ))
print('#' * 79)
print("The list is one of the most common and basic data structure in Python.\n It is a data structure for a mutable ordered sequence of elements")
print("mutable means it can be altered/ changed after being created without neccessarily creating a new object.\n ordered means each element in a list has an index(an integer that defines it's position in the list) and can be referenced/ obtained using that index")
print('#' * 79)
print("Lists are created using square brackets [] and can contain any data type(integer, float, boolean, strings) or even another data structure(container of data e.g another list)")
list_of_random_things = [1, 2.5, 'hello', True, -5, -0.9, '\\', False]
print("This is a list comprising of objects of different data types: {}".format(list_of_random_things))
print('#' * 79)
months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
print("Given a list of months like this; months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']: we can index into the list to get an individual month or slice the list to get a subsequence of the list as follows;")
print('#' * 79)
print("Get the first month as follows: months[0]- {}".format(months[0]))
print("Get the last month as follows: months[-1]- {}".format(months[-1]))
print("Get the first three months as follows: months[0:3]- {}".format(months[0:3]))
print('#' * 79)
print("Note that indexing starts from zero(counting from the front, the first index is zero and counting from the back, index starts from -1) and the slicing uses a lower bound and an upper bound separated by a full colon(:) where the lower bound(lower index) is inclusive(included in the result) and the upper bound(upper index) is exclusive(excluded from the list)")
print('#' * 79)
print("Slicing notation has shortcuts as follows:\n\t{}, {}, \n\t{}, {}".format("If the lower bound is from the start of the list, you can ommit the 0(start index) index and just give the upper bound e.g to print the first six months; months[:6]", months[:6], "If the upper bound is up to the end of the list, you can ommit the last index and just give the lower bound e.g to print the last six months; months[6:]", months[6:]))
print('#' * 79)
print("If you try accessing an index that does not access, you wil get a list index error exception. However, if you try to slice using bounds that are of indexes that do not exist in the list(either upper or lower bounds), you will just get an empty list back and not an error")
print('#' * 79)
print("List is a type just like int, float, str thus calling the type() function on it will give you:", type(months)) 
print('#' * 79)
print("The data type closest to a list is the string as both share some commonalities:\n\t1.Both are an ordered sequence of elements- the list being a sequence of elements of various data types separated by commas and delimited using square brackets and the string being an ordered sequence of characters wrapped in quote marks.\n\t2.Both support indexing i.e you can access any element using it's index in the string or list starting with index 0 from the front and -1 from the back.\n\t3.Both also support the len() function which returns the total number of elements in a list and the number of characters in a string including punctuations and spaces, new lines, tabs(any typeable character on the keyboard) counting from 1")
print('#' * 79)
print("The most notable difference between a string and list is that strings are immutable(cannot be changed once created without creating a new object) while lists are mutable(can be changed once created without having to create a completely new object)")
print('#' * 79)
print("Lists can be mutated in the following ways:")
print('#' * 79)
months.append('Pythoncember')
print("Using the append method which adds an element(one at a time) to the end of the list e.g we can add an 'imaginary' month to the end of our months list as follows months.append('Pythoncember') and printing the months list would reflect the new month:", months)
print('#' * 79)
months[0] = 'Jan'
print("Using the indexing notation, we can alter any index(valid index i.e an index that exists in the list) and assign it a new value e.g we can change the first month to a short form like so months[0] = 'Jan' and printing it out print(months) we see the change:", months)
print('#' * 79)
print("Using the del comand to delete any element by referencing it's index or delete multiple elements using the slicing notation or just delete the whole list by inputing it as the argument to the del function")
print('#' * 79)
months[:4] = ['Jan', 'Feb', 'Mar', 'Apr']
print("Using the slicing notation, we can alter any indices(valid indices i.e an index that exists in the list) or even indices that do not exist(Python will create new indices for them) and assign them a new value e.g we can change the first four months to a short form like so months[:4] = ['Jan', 'Feb'] and printing it out print(months) we see the change:", months)
print('#' * 79)
print("Note: When assigning values to variables, the variable is just a name for the value and the value is what gets stored in memory. (If you assign a value to a variable and then assign that variable to another variable, the value stored in that variable is what is stored in the new variable) thus there is a difference when we use two(or more) variables (names) to refer to the same value and alter one of them depending on whether that value is of a mutable or immutable type")
print('#' * 79)
print("If the type is immutable, then changing the value of one of the variables by reassigning does NOT change the value of the other variables that referenced the same value".upper())
print("If the type is mutable, then changing the value of one of the variables by reassigning changes the value of the other variables that referenced the same value".upper())
print('#' * 79)
print("Lists have a couple of methods that are helpful:")
print("len() returns the number of elements in the list e.g the len(months) is:", len(months))
print('#' * 79)
print("max() returns the largest element in the list. This is because it is defined using the greater than(>) operator. The result of this method is dependent on the contents of the list as follows:")
print("If the elements in the list are numbers, then max returns the largest number e.g max([20, 585, 67.90, -5, 456]) will return:", max([20, 585, 67.90, -5, 456]))
print('#' * 79)
print("If the elements in the list are a string, then max returns the string that would come last if the list was sorted alphabetically e.g max(['she', 'sells', 'sea','shells, 'by', 'the', 'sea', 'shore']) will return:", max(['she', 'sells', 'sea','shells', 'by', 'the', 'sea', 'shore']))
print('#' * 79)
print("min() returns the smallest element in the list. This is because it is defined using the less than(<) operator. The result of this method is dependent on the contents of the list as follows:")
print("If the elements in the list are numbers, then min returns the smallest number e.g min([20, 585, 67.90, -5, 456]) will return:", min([20, 585, 67.90, -5, 456]))
print('#' * 79)
print("If the elements in the list are a string, then min returns the string that would come first if the list was sorted alphabetically e.g max(['she', 'sells', 'sea','shells, 'by', 'the', 'sea', 'shore']) will return:", min(['she', 'sells', 'sea','shells', 'by', 'the', 'sea', 'shore']))
print('#' * 79)
print("While a list can have a mix and match of data types, the max and min methods are undefined for lists that consist of incomparable data types and will produce a TypeError")
print('#' * 79)
print("The join() method is a string method takes a list of elements that must be strings as an argument and returns a string that is the elements of the list separated by a separator string. The separator string is supplied before the method and calls the method using the dot operator e.g we can return our months list each month on a new line as follows '\\n'.join(months) :\n", '\n'.join(months))
print('#' * 79)
print("The split method is a string method that returns a list that contains the words from the input string. It is like a reverse of the join method e.g 'she sells sea shells by the sea shore'.split() will return: ", 'she sells sea shells by the sea shore'.split())
print('#' * 79)
print("The split method can take two more arguments, the maxsplit and the sep(separator). This define what string Python should use as the delimiter(space is the default) and the maximum number of splits(which returns the given number+1 elements as the list. The last element is what remains after the maxsplit is achieved)")
print('#' * 79)
print("The sorted() method returns a copy of the list with its elements arranged in ascending order. You can supply an extra argument to the method reverse=True to get the result in descending order e.g our months list -\n\t ascending: {}, \n\tdescending: {}".format(sorted(months), sorted(months, reverse=True)))